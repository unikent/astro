<template>
<el-dialog
	:title="`${modalType}${extraTitleText} Site Profile`"
	:visible.sync="visible"
	:modal-append-to-body="false"
	:before-close="promptToSave"
>
	<el-form :model="formData">
		<el-form-item v-for="(value, key, index) in schema"
			:label="schema[key].label"
			:key="key" 
			:class="{ 'is-required': schema[key].validation && schema[key].validation.rules[key][0].required === true }">
			<el-input
				v-if="schema[key].type === 'textarea'"
				v-model="formData[key]"
				type="textarea"
				:rows="5"
				:name="key"
				@blur="validate(index, key)"
				@change="validate(index, key)"
			>
				{{ schema[key].label }}
			</el-input>

			<div v-else-if="schema[key].type === 'richtext'" style="clear: left;">
				<rich-text v-model="formData[key]" />
			</div>

			<div v-else-if="schema[key].type === 'categories'" style="clear: left;">
				<el-checkbox-group v-model="formData[key]">

					<ul>
						<li v-for="category in availableCategories">
							<el-checkbox
								:label="category.id"
								:key="category.id"
								@change="(value) => resetChildCategories(value, category.id)"
							>
								{{ category.name }}
								<el-button
									v-if="!show[category.slug] && category.children && category.children.length"
									size="mini"
									@click="showSubcategories(category.slug)"
								>
									<i class="el-icon-plus el-icon-right" />
									Show subcategories
								</el-button>
							</el-checkbox>

							<ul v-if="show[category.slug] && category.children && category.children.length">
								<li v-for="subCategory in category.children">
									<el-checkbox
										:label="subCategory.id"
										:key="subCategory.id"
										@change="(value) => toggleParent(value, category.id)"
									>
										{{ subCategory.name }}
									</el-checkbox>
								</li>
							</ul>
						</li>
					</ul>

				</el-checkbox-group>
			</div>

			<div v-else-if="schema[key].type === 'social-media'" style="clear: left;">
				<el-row :gutter="4" v-for="(data, index) in formData[key]" :key="index">
					<el-col :span="6">
						<el-select v-model="data.id" placeholder="Social media platform">
							<el-option
								v-for="platform in availableSocialMedia"
								:label="platform.name"
								:value="platform.id"
								:key="platform.slug"
							>
							</el-option>
						</el-select>
					</el-col>
					<el-col :span="14">
						<el-input v-model="data.link" placeholder="URL">{{ schema[key].label }}</el-input>
					</el-col>
					<el-col :span="4">
						<el-button @click="removeSocialMediaPlatform(index)">Delete</el-button>
					</el-col>
				</el-row>

					<el-form-item>
						<el-button @click="addSocialMediaPlatform">Add social media</el-button>
					</el-form-item>
				
			</div>

			<el-input v-else :name="key"
				v-model="formData[key]"
				@blur="validate(index, key)"
				@change="validate(index, key)"
			>
			{{ schema[key].label }}</el-input>

			<div v-if="errors[index] && errors[index][key]" class="el-form-item__error">
				{{ errors[index][key].map((error)=> error.message).join(' ') }}
			</div>

		</el-form-item>
	</el-form>
	<span slot="footer" class="dialog-footer">
		<el-button @click="cancel">Cancel</el-button>
		<el-button type="primary" @click="createProfile">Save profile</el-button>
	</span>
</el-dialog>
</template>

<script>
import _ from 'lodash';
import Schema from 'async-validator';

import RichText from 'components/richtext';
import promptToSaveMixin from 'mixins/promptToSaveMixin';

export default {

	name: 'create-site-profile-modal',

	mixins: [
		promptToSaveMixin
	],

	components: {
		RichText
	},

	created() {
		this.blankProfile = {
			id: null,
			username: '',
			title: '',
			first_name: '',
			last_name: '',
			roles: '',
			email: '',
			telephone: '',
			location: '',
			office_hours: '',
			blog: '',
			personal_research_website: '',
			about: '',
			research_interest_highlights: '',
			research_interests: '',
			teaching: '',
			supervision: '',
			professional: '',
			date_published: '',
			past_work: '',
			socialmedia: [],
			categories: []
		};


		// filling up the initial errors with nulls to allow us fill out those out of order
		const numberOfFields = Object.entries(this.blankProfile).length;
		for (let index = 0; index < numberOfFields; index++) {
			this.errors.push(null);
		}

		this.schema = {
			username: {
				label: 'Username',
				validation: new Schema({
					username: {
						type: 'string',
						required: true,
						message: 'Username can\'t be empty.'
					}
				})
			},
			title: {
				label: 'Title',
				validation: new Schema({
					title: {
						type: 'string',
						required: true,
						message: 'Title can\'t be empty.'
					}
				})
			},
			first_name: {
				label: 'First name',
				validation: new Schema({
					first_name: {
						type: 'string',
						required: true,
						message: 'First name can\'t be empty.'
					}
				})
			},
			last_name: {
				label: 'Last name',
				validation: new Schema({
					last_name: {
						type: 'string',
						required: true,
						message: 'Second name can\'t be empty.'
					}
				})
			},
			roles: {
				label: 'Roles',
				validation: new Schema({
					roles: {
						type: 'string',
						required: true,
						message: 'Roles can\'t be empty.'
					}
				})
			},
			email: {
				label: 'Email',
				validation: new Schema({
					email: {
						type: 'string',
						required: true,
						message: 'Email can\'t be empty.'
					}
				})
			},
			telephone: {
				label: 'Telephone'
			},
			location: {
				label: 'Location',
				validation: new Schema({
					location: {
						type: 'string',
						required: true,
						message: 'Location can\'t be empty.'
					}
				})
			},
			office_hours: {
				label: 'Office hours'
			},
			blog: {
				label: 'Blog'
			},
			personal_research_website: {
				label: 'Personal research website'
			},
			about: {
				label: 'About',
				type: 'textarea',
				validation: new Schema({
					about: {
						type: 'string',
						required: true,
						message: 'About can\'t be empty.'
					}
				})
			},
			research_interest_highlights: {
				label: 'Research interest highlights',
			},
			research_interests: {
				label: 'Research interests',
				type: 'textarea'
			},
			teaching: {
				label: 'Teaching',
				type: 'richtext'
			},
			supervision: {
				label: 'Supervision',
				type: 'textarea'
			},
			professional: {
				label: 'Professional',
				type: 'textarea'
			},
			past_work: {
				label: 'Past work',
				type: 'textarea'
			},
			categories: {
				label: 'Categories',
				type: 'categories'
			},
			socialmedia: {
				label: 'Social media',
				type: 'social-media'
			}
		};

		this.$bus.$on('site-profile:showCreateProfileModal', ({ type, profileData }) => {
			this.type = type;
			this.visible = true;

			if (profileData) {
				this.formData = { ..._.cloneDeep(this.blankProfile), ...profileData };
			} else {
				this.formData = _.cloneDeep(this.blankProfile);
			}

			this.initialData = JSON.stringify(this.formData);
			this.show = {};
		});

		this.fetchCategories();
		this.fetchSocialMediaPlatforms();
	},

	data() {
		return {
			// promptToSaveMixin defines "initialData" property
			type: 'create',
			visible: false,
			formData: {},
			show: {},
			errors: [],
			availableSocialMedia: [{}],
			availableCategories: [{}],
		};
	},

	computed: {
		modalType() {
			return this.type.charAt(0).toUpperCase() + this.type.slice(1)
		},

		
		extraTitleText() {
			return (
				this.type === 'edit' && this.formData.last_name && this.formData.first_name ?
					` ${this.formData.first_name} ${this.formData.last_name}` +
					(this.formData.last_name.endsWith('s') ? '\'' : '\'s') :
					''
			);
		},

		isUnsaved() {
			return JSON.stringify(this.formData) !== this.initialData;
		}
	},

	methods: {

		toggleParent(checked, parentId) {
			if(checked && !this.formData.categories.includes(parentId)) {
				this.formData.categories.push(parentId);
			}
		},

		resetChildCategories(checked, categoryId) {
			if(!checked) {
				// get children of unchecked parent category
				const categoryChildren = this.availableCategories.find(
					category => category.id === categoryId
				).children;

				if(categoryChildren && categoryChildren.length) {
					const childIds = categoryChildren.map(
						childCategory => childCategory.id
					);

					// remove any selected subcategories that are in the
					// children of our unchecked parent category
					this.formData.categories = this.formData.categories.filter(
						catId => !childIds.includes(catId)
					);
				}
			}
		},

		validate(index, key) {
			console.log('validating... ', index, key);
			if (this.schema[key].validation) {
				console.log(this.schema[key], this.formData[key]);
				this.schema[key].validation.validate(this.formData, (errors, fields) => {
					// if errors exist set them, otherwise set to null
					this.errors.splice(index, 1, errors ? fields : null);

				});
			}
		},

		/*
		makes API request to update or create the profile
		*/
		createProfile() {
			let profileData = {};
			profileData.profile = (this.formData);

			let site_id = this.$route.params.site_id;

			if(this.type === 'edit') {
				var apiCall = this.$api.put;
				var endpoint = `sites/${site_id}/profiles/${this.formData.id}`
			} else {
				var apiCall = this.$api.post;
				var endpoint = `sites/${site_id}/profiles`;
			}

			apiCall(endpoint, profileData)
				.then((response) => {
					let savedProfile = response.data.data;
					this.visible = false;
					// tell the listing what we have changed
					this.$bus.$emit('site-profile:updatedProfileInList', savedProfile);
				})
				.catch((errors) => {
					// TODO - display some userful error here!
					console.log(errors);
				});

		},

		fetchSocialMediaPlatforms() {
				this.$api.get('profiles/socialmediaplatforms')
				.then(({data: json}) => {
					this.availableSocialMedia = _.cloneDeep(json.data);
				})
				.catch((errors) => {
					console.log(errors);
				});
		},

		fetchCategories() {
			this.$api.get('profiles/categories')
				.then(({data: json}) => {
					this.availableCategories = _.cloneDeep(json.data);
				})
				.catch((errors) => {
					console.log(errors);
				});
		},


		cancel() {
			this.promptToSave(success => {
				if(success) {
					this.visible = false;
				}
			});
		},

		addSocialMediaPlatform() {
			// TODO name seems not to be used at all - review this usage
			this.formData.socialmedia.push({
				id: null,
				link: '',
				name: ''
			});
		},

		removeSocialMediaPlatform(index) {
			this.formData.socialmedia.splice(index, 1);
		},

		showSubcategories(categorySlug) {
			this.show = { ...this.show, [categorySlug]: true };
		}

	}
};
</script>
